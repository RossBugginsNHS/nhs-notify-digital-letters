import fs from 'fs';
import path from 'path';
import yaml from 'js-yaml';

/**
 * Manual schema bundler that handles external HTTP refs gracefully
 * 
 * Bundle mode: Fully dereferences (inlines) all local file $refs, no $defs
 * Flatten mode: Dereferences + flattens allOf inheritance structures
 */

interface SchemaObject {
  [key: string]: any;
  $ref?: string;
  $defs?: Record<string, any>;
}

function isExternalRef(ref: string): boolean {
  return ref.startsWith('http://') || ref.startsWith('https://');
}

function resolveRefPath(currentFilePath: string, ref: string): string {
  const currentDir = path.dirname(currentFilePath);
  // Remove fragment if present
  const [refPath] = ref.split('#');
  return path.resolve(currentDir, refPath);
}

function loadSchema(filePath: string): SchemaObject {
  const content = fs.readFileSync(filePath, 'utf-8');
  if (filePath.endsWith('.yaml') || filePath.endsWith('.yml')) {
    return yaml.load(content) as SchemaObject;
  }
  return JSON.parse(content);
}

async function bundleSchema(
  entryPath: string,
  flatten: boolean = false
): Promise<SchemaObject> {
  const visited = new Set<string>();
  const circularRefs = new Map<string, any>(); // Track circular references
  
  // Dereference (inline) all $refs recursively
  function dereferenceSchema(schema: any, currentFile: string, refPath: string = ''): any {
    if (!schema || typeof schema !== 'object') {
      return schema;
    }
    
    if (Array.isArray(schema)) {
      return schema.map((item, idx) => dereferenceSchema(item, currentFile, `${refPath}[${idx}]`));
    }
    
    // Check for $ref first
    if (schema.$ref && typeof schema.$ref === 'string') {
      const ref = schema.$ref;
      
      // Keep external HTTP/HTTPS refs as-is
      if (isExternalRef(ref)) {
        return schema;
      }
      
      // Handle fragment-only refs (internal to current schema)
      if (ref.startsWith('#/')) {
        // Keep internal refs for now - they should be resolved in context
        return schema;
      }
      
      // Resolve and inline local file refs
      const [refFilePath, fragment] = ref.split('#');
      if (refFilePath) {
        const resolvedPath = resolveRefPath(currentFile, refFilePath);
        const refKey = `${resolvedPath}${fragment || ''}`;
        
        // Check for circular reference
        if (circularRefs.has(refKey)) {
          console.warn(`Circular reference detected: ${refKey}. Keeping as $ref.`);
          return schema;
        }
        
        // Mark as being processed
        circularRefs.set(refKey, true);
        
        try {
          const refSchema = loadSchema(resolvedPath);
          
          // If there's a fragment, navigate to it
          let target = refSchema;
          if (fragment) {
            const fragmentPath = fragment.substring(1).split('/'); // Remove leading '/'
            for (const segment of fragmentPath) {
              if (target && typeof target === 'object') {
                target = target[segment];
              } else {
                console.warn(`Could not resolve fragment ${fragment} in ${resolvedPath}`);
                circularRefs.delete(refKey);
                return schema;
              }
            }
          }
          
          // Recursively dereference the loaded schema
          const dereferenced = dereferenceSchema(target, resolvedPath, refKey);
          
          // Remove $id from inlined schemas to avoid conflicts
          if (dereferenced && typeof dereferenced === 'object' && dereferenced.$id) {
            const clean = { ...dereferenced };
            delete clean.$id;
            circularRefs.delete(refKey);
            return clean;
          }
          
          circularRefs.delete(refKey);
          return dereferenced;
        } catch (error: any) {
          console.warn(`Warning: Could not load ${resolvedPath}: ${error.message}. Keeping original ref.`);
          circularRefs.delete(refKey);
          return schema;
        }
      }
    }
    
    // Process all properties
    const result: any = {};
    for (const [key, value] of Object.entries(schema)) {
      result[key] = dereferenceSchema(value, currentFile, `${refPath}.${key}`);
    }
    
    return result;
  }
  
  // Load and dereference the entry schema
  const entrySchema = loadSchema(entryPath);
  visited.add(path.resolve(entryPath));
  
  let dereferenced = dereferenceSchema(entrySchema, entryPath);
  
  // Optionally flatten allOf
  if (flatten) {
    function flattenSchema(schema: any): any {
      if (!schema || typeof schema !== 'object') {
        return schema;
      }
      
      if (Array.isArray(schema)) {
        return schema.map(item => flattenSchema(item));
      }
      
      const result: any = {};
      
      // Process allOf if it exists
      if (Array.isArray(schema.allOf)) {
        const mergedProperties: Record<string, any> = {};
        const mergedRequired: Set<string> = new Set();
        const remainingAllOf: any[] = [];
        
        for (const item of schema.allOf) {
          const flattenedItem = flattenSchema(item);
          
          if (flattenedItem.$ref) {
            // Keep external refs in allOf
            if (isExternalRef(flattenedItem.$ref)) {
              remainingAllOf.push(flattenedItem);
            } else {
              // Internal refs shouldn't exist after dereferencing, but if they do, keep them
              remainingAllOf.push(flattenedItem);
            }
          } else if (flattenedItem.properties || flattenedItem.required) {
            // Merge properties
            if (flattenedItem.properties) {
              for (const [propKey, propValue] of Object.entries(flattenedItem.properties)) {
                mergedProperties[propKey] = flattenSchema(propValue);
              }
            }
            
            // Merge required
            if (Array.isArray(flattenedItem.required)) {
              flattenedItem.required.forEach((r: string) => mergedRequired.add(r));
            }
          } else {
            // Keep other constraints (oneOf, anyOf, if/then/else, etc.)
            remainingAllOf.push(flattenedItem);
          }
        }
        
        // Add merged properties to result
        if (Object.keys(mergedProperties).length > 0) {
          result.properties = mergedProperties;
        }
        if (mergedRequired.size > 0) {
          result.required = Array.from(mergedRequired);
        }
        
        // Keep remaining allOf if any
        if (remainingAllOf.length > 0) {
          result.allOf = remainingAllOf;
        }
      }
      
      // Copy all other properties (except allOf which we just processed)
      for (const [key, value] of Object.entries(schema)) {
        if (key !== 'allOf') {
          if (key === 'properties' && result.properties) {
            // Merge with existing properties from allOf
            result.properties = { ...result.properties, ...flattenSchema(value) };
          } else if (key === 'required' && result.required) {
            // Merge with existing required from allOf
            const existingRequired = new Set(result.required);
            if (Array.isArray(value)) {
              value.forEach((r: string) => existingRequired.add(r));
            }
            result.required = Array.from(existingRequired);
          } else {
            result[key] = flattenSchema(value);
          }
        }
      }
      
      return result;
    }
    
    dereferenced = flattenSchema(dereferenced);
  }
  
  return dereferenced;
}

async function main() {
  const args = process.argv.slice(2);
  let flatten = false;
  let rootDir: string | undefined;
  const filtered: string[] = [];

  for (let i = 0; i < args.length; i++) {
    const a = args[i];
    if (a === '--flatten' || a === '--flatten-allof') {
      flatten = true;
    } else if (a === '--root-dir' && i + 1 < args.length) {
      rootDir = args[i + 1];
      i++;
    } else {
      filtered.push(a);
    }
  }

  const [entry, outFile] = filtered;
  if (!entry || !outFile) {
    console.error('Usage: ts-node manual-bundle-schema.ts [--flatten] [--root-dir <path>] <entry-schema> <output-file>');
    process.exit(1);
  }

  const entryPath = path.isAbsolute(entry) ? entry : path.join(process.cwd(), entry);
  if (!fs.existsSync(entryPath)) {
    console.error(`Entry schema not found: ${entryPath}`);
    process.exit(1);
  }

  try {
    const bundled = await bundleSchema(entryPath, flatten);
    
    // Set $id
    const outFileAbs = path.isAbsolute(outFile) ? outFile : path.join(process.cwd(), outFile);
    const repoRoot = rootDir ? path.resolve(rootDir) : process.cwd();
    const outputRoot = path.join(repoRoot, 'output');

    let schemaId: string;
    if (outFileAbs.startsWith(outputRoot)) {
      schemaId = "/" + path.relative(outputRoot, outFileAbs).replace(/\\/g, '/');
    } else if (outFileAbs.includes('/schemas/')) {
      const schemasRoot = path.join(repoRoot, 'schemas');
      const relativePath = path.relative(schemasRoot, outFileAbs).replace(/\\/g, '/');
      schemaId = `https://notify.nhs.uk/cloudevents/schemas/${relativePath}`;
    } else {
      schemaId = path.basename(outFile);
    }

    // Build properly ordered output with metadata first
    const orderedOutput: any = {};
    
    // Standard JSON Schema metadata fields first
    if (bundled.$id) orderedOutput.$id = bundled.$id;
    orderedOutput.$id = schemaId;
    if (bundled.$schema) orderedOutput.$schema = bundled.$schema;
    if (bundled.title) orderedOutput.title = bundled.title;
    if (bundled.description) orderedOutput.description = bundled.description;
    if (bundled.type) orderedOutput.type = bundled.type;
    
    // Then structural fields
    if (bundled.allOf) orderedOutput.allOf = bundled.allOf;
    if (bundled.properties) orderedOutput.properties = bundled.properties;
    if (bundled.required) orderedOutput.required = bundled.required;
    
    // Then any other fields
    for (const [key, value] of Object.entries(bundled)) {
      if (!['$id', '$schema', 'title', 'description', 'type', 'allOf', 'properties', 'required', '$comment'].includes(key)) {
        orderedOutput[key] = value;
      }
    }
    
    // $comment last
    orderedOutput.$comment = ((bundled.$comment ? bundled.$comment + ' | ' : '') + 
      (flatten ? 'Fully dereferenced and flattened (all local $refs inlined, allOf merged).' : 'Fully dereferenced (all local $refs inlined).'));

    const outDir = path.dirname(path.resolve(outFile));
    fs.mkdirSync(outDir, { recursive: true });
    fs.writeFileSync(outFile, JSON.stringify(orderedOutput, null, 2));
    console.log(`✅ ${flatten ? 'Flattened' : 'Bundled'} schema written to ${outFile}`);
  } catch (err) {
    console.error('Failed to bundle schema:', err);
    process.exit(1);
  }
}

main();
